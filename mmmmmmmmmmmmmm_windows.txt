原文连接：
https://github.com/Tencent/ncnn/wiki/how-to-build#build-for-windows-x64-using-visual-studio-community-2017


(1)
安装vs2017，https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/#visual-studio-2017-and-other-products
需要登录后下载，建议下载Community社区版。在安装时需要在工作负荷一栏中勾选 使用C++的桌面开发 和 通用Windows平台开发，
并在语言包一栏中选择 英语。



(2)
解压protobuf-3.4.0.zip到D://下，
桌面左下角点放大镜，搜索x64 Native Tools Command Prompt for VS 2017，右键以管理员身份运行

输入以下命令编译安装protobuf-3.4.0，
(注意，本压缩包protobuf-3.4.0.zip已经编译安装过，如果想重新编译安装，删除build文件夹再运行以下命令)

d:
cd D://protobuf-3.4.0
mkdir build
cd build
cmake -G"NMake Makefiles" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=%cd%/install -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_MSVC_STATIC_RUNTIME=OFF ../cmake
nmake
nmake install


(3)
解压opencv.zip到D://下，


(4)
解压MinGW (gcc9.2.0-2) 只安装了gnu 四个编译器.rar到D://下，
添加环境变量
MinGW_PATH=D:\MinGW
PATH后接
%MinGW_PATH%\bin
%MinGW_PATH%\include
%MinGW_PATH%\lib


gcc --version


输出版本信息表示安装成功。

(5)
双击VulkanSDK-1.3.204.1-Installer.exe，可选的组件全部都不勾选，安装路径选择D:\VulkanSDK\1.3.204.1
添加环境变量
VULKAN_SDK=D:\VulkanSDK\1.3.204.1
VK_SDK_PATH=D:\VulkanSDK\1.3.204.1
PATH后接
%VULKAN_SDK%\Bin

必须要关掉上面打开的x64 Native Tools Command Prompt for VS 2017终端，
重新以管理员身份运行这个终端，环境变量才生效。

(6)
构建ncnn库
桌面左下角点放大镜，搜索x64 Native Tools Command Prompt for VS 2017，右键以管理员身份运行
(其中的cmake命令有3处要指定protobuf的安装路径为D://protobuf-3.4.0，根据实际安装路径修改
其中的cmake命令有1处要指定opencv库中OpenCVConfig.cmake文件的路径，即-DOpenCV_DIR=D://opencv/build，根据实际安装路径修改
)

d:

cd D://GitHub/ncnn

cd D://GitHub/ncnn2


mkdir -p build

cd build

cmake -G"NMake Makefiles" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=%cd%/install -DProtobuf_INCLUDE_DIR=D://protobuf-3.4.0/build/install/include -DProtobuf_LIBRARIES=D://protobuf-3.4.0/build/install/lib/libprotobuf.lib -DProtobuf_PROTOC_EXECUTABLE=D://protobuf-3.4.0/build/install/bin/protoc.exe -DOpenCV_DIR=D://opencv/build -DNCNN_VULKAN=ON ..

nmake

nmake install


如果nmake报错
ncnn\src\mat.h(18): fatal error C1083: Cannot open include file: 'stdlib.h': No such file or directory
include_directories(D:\MinGW\include)


如果nmake报错
ncnn\glslang\glslang\genericcodegen\../Include/Common.h(40): fatal error C1083: Cannot open include file: 'algorithm': No such file or directory
include_directories(D:\MinGW\lib\gcc\mingw32\9.2.0\include\c++\experimental)


include_directories(D:\MinGW\lib\gcc\mingw32\9.2.0\include)





(7)
运行示例（在pycharm的普通终端输入）：
cd build/examples
.\squeezenet ../../images/256-ncnn.png ../../examples/squeezenet_v1.1.param ../../examples/squeezenet_v1.1.bin


重新编译（在x64 Native Tools Command Prompt for VS 2017终端输入）
cmake -G"NMake Makefiles" -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=%cd%/install -DProtobuf_INCLUDE_DIR=D://protobuf-3.4.0/build/install/include -DProtobuf_LIBRARIES=D://protobuf-3.4.0/build/install/lib/libprotobuf.lib -DProtobuf_PROTOC_EXECUTABLE=D://protobuf-3.4.0/build/install/bin/protoc.exe -DOpenCV_DIR=D://opencv/build -DNCNN_VULKAN=ON ..

nmake

nmake install



cd ../benchmark
.\../build/benchmark/benchncnn 10 $(nproc) 0 0





---------------------------------------------------------------
源码解读：
squeezenet.load_param(param_path);调用的是
src/net.cpp的
int Net::load_param(const char* protopath)
最后调用
int Net::load_param(const DataReader& dr)
解读模型结构。


squeezenet_v1.1.param文件内容：
7767517
75 83
Input            data             0 1 data 0=227 1=227 2=3
Convolution      conv1            1 1 data conv1 0=64 1=3 2=1 3=2 4=0 5=1 6=1728
ReLU             relu_conv1       1 1 conv1 conv1_relu_conv1 0=0.000000
...

第1行的7767517是版本号？反正当前版本就是这个固定的值。
第2行的75表示层的数量layer_count，83表示张量的数量blob_count，
第3行依次是层的类型layer_type、层的名字layer_name、输入张量数量bottom_count、输出张量数量top_count，再之后，先是所有输入张量的名字，再是所有输出张量的名字；
最后，带有"="的是层的属性。比如，Input层的0=227 1=227 2=3表示(源码在src/layer/input.cpp)
    w = pd.get(0, 0);
    h = pd.get(1, 0);
    d = pd.get(11, 0);
    c = pd.get(2, 0);
Convolution层的0=64 1=3 2=1 3=2 4=0 5=1 6=1728表示(源码在src/layer/convolution.cpp)
    num_output = pd.get(0, 0);
    kernel_w = pd.get(1, 0);
    kernel_h = pd.get(11, kernel_w);
    dilation_w = pd.get(2, 1);
    dilation_h = pd.get(12, dilation_w);
    stride_w = pd.get(3, 1);
    stride_h = pd.get(13, stride_w);
    pad_left = pd.get(4, 0);
    pad_right = pd.get(15, pad_left);
    pad_top = pd.get(14, pad_left);
    pad_bottom = pd.get(16, pad_top);
    pad_value = pd.get(18, 0.f);
    bias_term = pd.get(5, 0);
    weight_data_size = pd.get(6, 0);
    int8_scale_term = pd.get(8, 0);
    activation_type = pd.get(9, 0);
    activation_params = pd.get(10, Mat());

    dynamic_weight = pd.get(19, 0);
6=1728=64*3*3*3=weight_data_size=权重w的元素数量



SCAN_VALUE("%d", magic) 表示的是扫描下一个的值（作为整型）赋值给magic。

char bottom_name[256];
SCAN_VALUE("%255s", bottom_name) 表示的是扫描下一个的值（作为字符串）赋值给bottom_name，最大长度为255，不足的在字符串s左边补空格。



src/layer.h的表示了层类Layer，它有这些属性：
    // 这个层的输入张量的下标
    std::vector<int> bottoms;
    // 这个层的输出张量的下标
    std::vector<int> tops;




